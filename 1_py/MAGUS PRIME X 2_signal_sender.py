import logging
import os

import requests
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

from bot_dev_backup import get_timeframe, is_weekend, is_crypto, market_is_open, WEEKEND_CRYPTO_ONLY

class SignalSender:
    """
    A class to send trading signals to a Telegram channel or other destinations.
    Uses enhanced send_signal function for dispatch.
    """

    def __init__(self):
        """Initialize with API credentials from environment variables"""
        self.bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
        self.chat_id = os.getenv(
            "TELEGRAM_GROUP_ID"
        )  # Updated to use GROUP_ID instead of CHAT_ID
        self.api_key = "magus_prime_secret_key"  # API key for dispatcher service

        # Configure logging
        self.logger = logging.getLogger("SignalSender")
        self.logger.setLevel(logging.INFO)
        if not self.logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
            )
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)

        # Validate credentials
        if not self.bot_token or not self.chat_id:
            self.logger.warning("Missing Telegram credentials in environment variables")

    def send_signal(
        self,
        pair,
        entry,
        stop_loss,
        tp1,
        tp2=None,
        tp3=None,
        timeframe="30m",
        mode="SMART_RECOVERY",
        signal_type="Breakout",
        platform="Capital.com",
    ):
        """
        Send a trading signal using the enhanced signal dispatcher.

        Args:
            pair (str): Trading pair symbol (e.g., "GOLD", "BTCUSD")
            entry (float): Entry price
            stop_loss (float): Stop loss price
            tp1 (float): Take profit 1 price
            tp2 (float, optional): Take profit 2 price
            tp3 (float, optional): Take profit 3 price
            timeframe (str, optional): Trading timeframe. Defaults to "30m"
            mode (str, optional): Trading mode. Defaults to "SMART_RECOVERY"
            signal_type (str, optional): Type of signal. Defaults to "Breakout"
            platform (str, optional): Trading platform. Defaults to "Capital.com"

        Returns:
            dict: Response from the signal dispatch service
        """
        self.logger.info(f"Sending {signal_type} signal for {pair}")

        # Helper function to escape HTML special characters
        def escape_html(text):
            """Escape HTML special characters"""
            return (
                str(text)
                .replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
            )

        # Format message with proper HTML escaping
        message = f"""
üö® <b>TRADING SIGNAL</b> üö®

üîπ <b>Pair:</b> {escape_html(pair)}
üîπ <b>Type:</b> {escape_html(signal_type)}
üîπ <b>Timeframe:</b> {escape_html(timeframe)}
üîπ <b>Platform:</b> {escape_html(platform)}

üí∞ <b>Entry:</b> {escape_html(entry)}
üõë <b>Stop Loss:</b> {escape_html(stop_loss)}
‚úÖ <b>TP1:</b> {escape_html(tp1)}"""

        if tp2 is not None:
            message += f"\n‚úÖ <b>TP2:</b> {escape_html(tp2)}"
        if tp3 is not None:
            message += f"\n‚úÖ <b>TP3:</b> {escape_html(tp3)}"

        message += "\n\nGenerated by MAGUS PRIME X"

        # Use the direct Telegram API for sending
        if self.bot_token and self.chat_id:
            url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
            data = {"chat_id": self.chat_id, "text": message, "parse_mode": "HTML"}

            try:
                response = requests.post(url, json=data, timeout=10)
                response.raise_for_status()
                self.logger.info(f"Signal sent successfully for {pair}")
                return {
                    "success": True,
                    "message_id": response.json().get("result", {}).get("message_id"),
                }
            except Exception as e:
                self.logger.error(f"Failed to send signal: {e}")
                return {"error": str(e)}
        else:
            self.logger.error("Missing Telegram credentials")
            return {"error": "Missing Telegram credentials"}

    def send_direct_telegram(self, message):
        """
        Send a message directly to Telegram without using the dispatcher.

        Args:
            message (str): Message text to send

        Returns:
            dict: Response from Telegram API
        """
        if not self.bot_token or not self.chat_id:
            self.logger.error("Missing Telegram credentials")
            return {"error": "Missing Telegram credentials"}

        url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
        data = {"chat_id": self.chat_id, "text": message, "parse_mode": "HTML"}

        try:
            response = requests.post(url, json=data, timeout=10)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            self.logger.error(f"Failed to send direct Telegram message: {e}")
            return {"error": str(e)}

    def generate_signal(self, symbol):
        """Generate a signal for the given symbol with market availability check"""
        # Check weekend restrictions
        if WEEKEND_CRYPTO_ONLY and is_weekend() and not is_crypto(symbol):
            self.logger.warning(f"Skipping signal generation for {symbol} - Only crypto allowed on weekends")
            return None
            
        # Check if market is open
        if not market_is_open(symbol):
            self.logger.warning(f"Skipping signal generation for {symbol} - Market is closed")
            return None
            
        # Continue with existing signal generation logic    
        strategy_type = self._determine_strategy_type(symbol)
        timeframe = get_timeframe(strategy_type)
        
        signal = {
            "symbol": symbol,
            "direction": self._determine_direction(symbol),
            "strategy": strategy_type,
            "timeframe": timeframe,
            # ...other signal data...
        }
        
        return signal

    async def send_signal(self, symbol, signal_data):
        """Send trading signal with market availability check"""
        # Check weekend restrictions
        if WEEKEND_CRYPTO_ONLY and is_weekend() and not is_crypto(symbol):
            self.logger.warning(f"Not sending signal for {symbol} - Only crypto allowed on weekends")
            return False
            
        # Check if market is open
        if not market_is_open(symbol):
            self.logger.warning(f"Not sending signal for {symbol} - Market is closed")
            return False
            
        # Continue with existing send signal logic
        # ...existing code...

    async def send_trade_recap(self, symbol, direction, entry, tp1, tp2, tp3, sl, result, hit_level, timeframe, asset_type):
        """Send a recap message for a completed trade"""
        # Format the result with color
        if "Profit" in result:
            result_formatted = f"‚úÖ {result}"
        else:
            result_formatted = f"‚ùå {result}"
        
        # Helper function to escape HTML special characters
        def escape_html(text):
            """Escape HTML special characters"""
            return (
                str(text)
                .replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
            )
        
        message = f"""
    üìä <b>Trade Recap: {escape_html(symbol)}</b>

    üîπ <b>Type:</b> {escape_html(direction.upper())}
    üîπ <b>Result:</b> <b>{escape_html(result_formatted)}</b> ‚Äî {escape_html(hit_level)}
    üîπ <b>Timeframe:</b> {escape_html(timeframe)}
    üîπ <b>Asset Type:</b> {escape_html(asset_type)}

    üí∞ <b>Entry:</b> {escape_html(entry)}
    ‚úÖ <b>TP1:</b> {escape_html(tp1)}
    ‚úÖ <b>TP2:</b> {escape_html(tp2)}
    ‚úÖ <b>TP3:</b> {escape_html(tp3)}
    üõë <b>SL:</b> {escape_html(sl)}

    Generated by <b>MAGUS PRIME X Bot</b>
    """
        
        # Use direct Telegram sending
        if self.bot_token and self.chat_id:
            url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
            data = {"chat_id": self.chat_id, "text": message, "parse_mode": "HTML"}

            try:
                response = requests.post(url, json=data, timeout=10)
                response.raise_for_status()
                self.logger.info(f"Trade recap sent for {symbol}")
                return True
            except Exception as e:
                self.logger.error(f"Failed to send trade recap: {e}")
                return False
        else:
            self.logger.error("Missing Telegram credentials")
            return False

    def _determine_strategy_type(self, symbol):
        """Determine if symbol is better for scalping or swing trading"""
        # This is a simple example; implement your own logic
        volatile_symbols = ["BTCUSD", "ETHUSD", "XAUUSD"]
        return "scalping" if symbol in volatile_symbols else "swing"


# Example usage
if __name__ == "__main__":
    sender = SignalSender()
    result = sender.send_signal(
        pair="GOLD",
        entry=3110.50,
        stop_loss=3095.75,
        tp1=3125.25,
        tp2=3140.00,
        tp3=3160.50,
        timeframe="1h",
        signal_type="Breakout",
    )
    print(f"Result: {result}")

# Create a standalone function that uses the class method
async def send_trade_recap(symbol, direction, entry, tp1, tp2, tp3, sl, result, hit_level, timeframe, asset_type):
    """
    Global function to send a trade recap using the SignalSender class
    """
    sender = SignalSender()
    return await sender.send_trade_recap(symbol, direction, entry, tp1, tp2, tp3, sl, result, hit_level, timeframe, asset_type)
